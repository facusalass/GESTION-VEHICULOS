# üöó Trabajo Final: Sistema de Gesti√≥n de Veh√≠culos

## üìÑ Descripci√≥n del Proyecto
Este proyecto es una aplicaci√≥n de consola en Java que simula la administraci√≥n de una flota de veh√≠culos. El objetivo principal fue integrar todos los conceptos vistos en la cursada sobre **Programaci√≥n Orientada a Objetos (POO)**.

El sistema permite dar de alta veh√≠culos (diferenciando entre Autos y Motos), listarlos, buscarlos y registrar mantenimientos, asegurando que el programa sea robusto y no se rompa ante errores del usuario.

---

## üë• Integrantes y Divisi√≥n de Tareas
Para el desarrollo, dividimos la l√≥gica en capas para tener un c√≥digo m√°s limpio:

* **Integrante 1:** Dise√±o del Modelo de Datos (Clases `Vehiculo`, `Auto`, `Moto`).
* **Integrante 2:** L√≥gica de Negocio y Colecciones (`GestionVehiculos`).
* **Integrante 3:** Interfaz de Usuario y Validaciones de entrada (`Main`).
* **Integrante 4 (Yo):** Manejo de Excepciones Personalizadas (`ElementoNoEncontradoException`), Documentaci√≥n y armado final.

---

## üõ†Ô∏è Explicaci√≥n T√©cnica por Opci√≥n del Men√∫

A continuaci√≥n, detallo qu√© hace cada funci√≥n del sistema y **qu√© consigna de la materia cumple**:

### 1Ô∏è‚É£ Opci√≥n 1: Agregar Veh√≠culo
* **Funcionalidad:** Pide los datos al usuario. Lo interesante es que detecta si es "Auto" o "Moto" para pedir el dato espec√≠fico (puertas o cilindrada) y luego lo guarda en una lista √∫nica.
* **Conceptos aplicados:**
    * **Herencia y Polimorfismo:** Aunque instanciamos objetos distintos (`new Auto` o `new Moto`), ambos se guardan en una lista de tipo `Vehiculo`.
    * **Manejo de Tipos:** Usamos `try-catch` b√°sicos aqu√≠ para evitar que el programa se cierre si el usuario pone letras en el kilometraje.

### 2Ô∏è‚É£ Opci√≥n 2: Listar Veh√≠culos
* **Funcionalidad:** Muestra todos los veh√≠culos cargados en memoria.
* **Conceptos aplicados:**
    * **Colecciones (List/ArrayList):** Recorremos la lista din√°mica donde est√°n guardados los datos.
    * **Sobrescritura (Override):** Cada clase tiene su propio m√©todo `toString()`, por lo que el listado se ve diferente y formateado seg√∫n si el objeto es un Auto o una Moto.

### 3Ô∏è‚É£ Opci√≥n 3: Buscar Veh√≠culo
* **Funcionalidad:** El usuario ingresa una patente y el sistema busca si existe.
* **Conceptos aplicados:**
    * **Streams y Optional:** Usamos la API de Streams para filtrar la lista de forma eficiente. El resultado se maneja con un `Optional` para evitar el famoso error *NullPointerException* si no se encuentra nada.

### 4Ô∏è‚É£ Opci√≥n 4: Registrar Mantenimiento 
* **Funcionalidad:** Se intenta cargar un servicio a un veh√≠culo. Si la patente no existe, el sistema no falla silenciosamente ni se rompe.
* **Conceptos aplicados:**
    * **Excepciones Propias:** Cre√© la clase `ElementoNoEncontradoException`. En lugar de devolver un simple `null` o `false`, el m√©todo **lanza** (throws) esta excepci√≥n espec√≠fica.
    * **Bloque Try-Catch-Finally:** En el `Main`, encerramos esta llamada en un bloque de control. Si la patente no existe, "atrapamos" el error y le mostramos al usuario un mensaje claro (`‚õî ERROR: ...`), demostrando un control de flujo robusto.

### 5Ô∏è‚É£ Opci√≥n 5: Historial de Usuario
* **Funcionalidad:** Muestra las √∫ltimas 5 opciones que eligi√≥ el usuario.
* **Conceptos aplicados:**
    * **Arreglos (Arrays):** Usamos un vector est√°tico `String[5]`.
    * **Algoritmos (Buffer Circular):** Para no tener que borrar y mover todo el array cada vez que se llena, usamos l√≥gica matem√°tica con el operador m√≥dulo (`%`). Esto hace que, al llegar a la posici√≥n 5, vuelva a empezar por la 0, guardando siempre lo m√°s reciente.

---

## üöÄ C√≥mo correr el proyecto
1. Abrir el proyecto en IntelliJ o Eclipse.
2. Ir a la clase `Main.java`.
3. Darle a **Run**.
4. Usar la consola para interactuar con el men√∫.
